# Planner-Solver (规划-求解) Agent

## 一、设计思想

### 核心概念

> **"分而治之" - 将复杂问题分解为可管理的子任务**

Planner-Solver 是一种两阶段的 Agent 架构模式，将问题解决过程分为**规划**和**执行**两个独立的阶段：

```
用户问题 → Planner（规划） → 计划 → Solver（求解） → 最终答案
```

---

## 二、与 ReAct 的对比

| 维度 | ReAct | Planner-Solver |
|------|-------|----------------|
| **执行方式** | 边想边做 (Thought-Action-Observe) | 先规划后执行 |
| **决策时机** | 每一步都决策 | 集中规划后执行 |
| **适应性** | 高（可动态调整） | 中（按计划执行） |
| **可解释性** | 显式思考过程 | 显式计划 + 执行 |
| **适用场景** | 需要灵活探索的任务 | 可预先分解的任务 |

---

## 三、核心架构

### 1. Planner Agent（规划者）

**职责：**
- 理解用户问题
- 分析问题结构
- 制定执行计划（子任务列表）

**输出格式：**
```text
Plan:
1. 第一步做什么
2. 第二步做什么
3. 第三步做什么
...
```

### 2. Solver Agent（求解者）

**职责：**
- 接收 Planner 生成的计划
- 依次执行每个子任务
- 调用工具获取信息
- 汇总结果

**工作流程：**
```
对于计划中的每一步：
  Thought: 分析当前步骤
  Action: 调用工具
  Observation: 获取结果
```

---

## 四、工作流程详解

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户提出复杂问题                           │
└─────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Planner Agent（规划阶段）                     │
│                                                                  │
│  - 分析问题                                                       │
│  - 识别所需信息                                                   │
│  - 制定执行计划                                                   │
│  - 输出: Step1 → Step2 → Step3 → ...                             │
└─────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Solver Agent（执行阶段）                      │
│                                                                  │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                   │
│  │ Step 1   │ →  │ Step 2   │ →  │ Step 3   │                   │
│  │ (ReAct)  │    │ (ReAct)  │    │ (ReAct)  │                   │
│  └──────────┘    └──────────┘    └──────────┘                   │
│                                                                  │
│  - 依次执行各步骤                                                 │
│  - 使用 ReAct 模式调用工具                                       │
│  - 收集每步结果                                                   │
└─────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                      汇总并返回最终答案                           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、设计优势

### 1. 清晰的问题分解

复杂问题被显式地分解为清晰的步骤，易于理解和调试。

### 2. 减少盲目探索

通过预先规划，避免了 ReAct 模式下可能的无效探索。

### 3. 可复用的计划

对于相似的问题，规划可以复用。

### 4. 独立的优化空间

Planner 和 Solver 可以分别优化：
- Planner 可以优化规划策略
- Solver 可以优化工具使用效率

---

## 六、典型应用场景

### 场景 1: 复杂研究任务

```
问题: "分析特斯拉公司最近的财务状况，并与比亚迪比较"

Planner 输出:
1. 获取特斯拉最新财务数据
2. 获取比亚迪最新财务数据
3. 对比两家公司的关键财务指标
4. 分析各自的优劣势

Solver 执行:
- 依次执行上述步骤
- 每步可能需要多次工具调用
```

### 场景 2: 多步骤代码开发

```
问题: "创建一个待办事项 API"

Planner 输出:
1. 设计 API 端点结构
2. 编写数据模型
3. 实现核心业务逻辑
4. 添加错误处理
5. 编写测试用例
```

### 场景 3: 数据分析流程

```
问题: "分析这份销售数据并给出建议"

Planner 输出:
1. 加载并清洗数据
2. 进行统计分析
3. 识别趋势和异常
4. 生成可视化图表
5. 给出业务建议
```

---

## 七、Prompt 设计

### Planner Prompt 模板

```python
PLANNER_PROMPT = """你是一个专业的任务规划专家。你的职责是将复杂问题分解为清晰的执行步骤。

## 可用工具
{tools}

## 工作流程
1. 仔细分析用户的问题
2. 识别需要哪些信息
3. 确定步骤的合理顺序
4. 输出详细的执行计划

## 输出格式
请严格按照以下格式输出：

Plan:
1. [第一步描述]
2. [第二步描述]
3. [第三步描述]
...

## ⚠️ 重要提醒
- 每个步骤应该是具体可执行的
- 步骤之间应该有逻辑顺序
- 考虑哪些步骤可以合并
- 通常 3-5 个步骤比较合适

## 当前任务
**Question:** {question}

现在开始规划："""
```

### Solver Prompt 模板

```python
SOLVER_PROMPT = """你是一个任务执行专家。你需要按照给定的计划，一步步完成任务。

## 可用工具
{tools}

## 执行计划
{plan}

## 当前步骤
当前执行: {current_step}
进度: {step_index} / {total_steps}

## 已完成步骤的结果
{previous_results}

## 工作流程
请严格按照以下格式进行回应：

Thought: 分析当前步骤，确定需要什么信息
Action: 选择合适的工具获取信息，格式为：
- `{{tool_name}}[{{参数}}]`：调用工具获取信息
- `Finish[结论]`：当当前步骤完成时

## ⚠️ 重要提醒
1. 专注于完成当前步骤
2. 如果当前步骤需要多次工具调用，继续调用直到完成
3. 完成当前步骤后使用 Finish，不要试图跳到下一步

现在开始执行当前步骤："""
```

---

## 八、关键设计决策

### 1. Planner 使用轻量级模型

Planner 只需要规划，不需要复杂的工具调用，可以使用更快的模型。

### 2. Solver 使用 ReAct 模式

Solver 在执行每个步骤时，采用 ReAct 模式，保留了灵活探索的能力。

### 3. 步骤间的结果传递

每步的结果会被传递给下一步，形成上下文链。

### 4. 支持计划调整

如果某步失败，可以选择：
- 跳过该步继续
- 重新规划
- 终止并报告

---

## 九、与 ReAct 的互补关系

```
ReAct                    Planner-Solver
─────────────────        ┌─────────────────┐
  边想边做     ────────▶  │     先想后做      │
  灵活探索     ────────▶  │     结构化执行    │
  适合开放问题  ────────▶  │     适合复杂任务  │
  可能走弯路    ────────▶  │     减少冗余步骤  │
└─────────────────┘      └─────────────────┘
```

**建议：**
- 简单任务 → ReAct（更快，更灵活）
- 复杂任务 → Planner-Solver（更结构化）

---

## 十、实现要点

### 1. 状态管理

```python
class PlannerSolverAgent:
    def __init__(self):
        self.planner_llm: VerAgentLLM      # 规划用 LLM
        self.solver_llm: VerAgentLLM       # 求解用 LLM
        self.tool_registry: ToolRegistry   # 工具注册表
        self.plan: List[str] = []          # 执行计划
        self.step_results: List[str] = []  # 各步结果
```

### 2. 流程控制

```python
def run_stream(self, input_text: str):
    # 阶段 1: 规划
    yield from self._planning_phase(input_text)

    # 阶段 2: 执行
    for i, step in enumerate(self.plan):
        yield from self._execution_phase(i, step)

    # 阶段 3: 汇总
    yield from self._summary_phase()
```

### 3. 流式输出

保持与 ReAct 一致的流式输出体验：
- 规划过程可见
- 每步执行可见
- 最终结果清晰

---

## 十一、局限性

1. **规划阶段依赖 LLM 能力**：如果 Planner 规划不当，会影响整体效果
2. **缺乏动态调整**：计划一旦制定，调整灵活性不如 ReAct
3. **两阶段开销**：需要额外的规划时间和 token 消耗

---

## 十二、未来扩展方向

1. **动态重规划**：执行中遇到问题时自动调整计划
2. **并行执行**：识别可并行执行的步骤
3. **计划缓存**：对相似问题复用计划
4. **反思机制**：执行后评估计划质量，持续改进

---

## 十三、参考文献

1. Plan-and-Solve Prompting (Wang et al., 2023)
2. ReAct: Synergizing Reasoning and Acting (Yao et al., 2022)
3. Tree of Thoughts (Yao et al., 2023)
4. Reflexion (Shinn et al., 2023)
